AWSTemplateFormatVersion: "2010-09-09"
Description: PDC Minimalist Infrastructure - Fargate & DynamoDB

Parameters:
  GitHubOAuthToken:
    Type: String
    Description: GitHub OAuth token with repo access for CodePipeline source stage
    NoEcho: true # hides the value in the CloudFormation console and API responses

Resources:
  # --- Network Infrastructure ---
  PDCVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true

  PDCPublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref PDCVPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs ""] # select the first AZ in the region

  # --- Internet Gateway ---
  PDCInternetGateway:
    Type: AWS::EC2::InternetGateway

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref PDCVPC
      InternetGatewayId: !Ref PDCInternetGateway

  # --- Route Table for Public Subnet ---
  PDCPublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref PDCVPC

  PDCPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PDCPublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0 # any non-local traffic goes to this route
      GatewayId: !Ref PDCInternetGateway #exit point of this route

  PDCSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PDCPublicSubnet
      RouteTableId: !Ref PDCPublicRouteTable

  # --- Private Subnet for Fargate (API containers run here) ---
  PDCPrivateSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref PDCVPC
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: false # Private subnet - no public IPs
      AvailabilityZone: !Select [0, !GetAZs ""]

  # --- Elastic IP for NAT Gateway --- # if we wanted stuff in the private subnets to access the internet. (we just need them to hit ECR so we are using an interface endpoint)
  # PDCNATGatewayEIP:
  #   Type: AWS::EC2::EIP
  #   DependsOn: AttachGateway
  #   Properties:
  #     Domain: vpc

  # --- NAT Gateway (in public subnet for private subnet internet access) ---
  # PDCNATGateway:
  #   Type: AWS::EC2::NatGateway
  #   Properties:
  #     AllocationId: !GetAtt PDCNATGatewayEIP.AllocationId
  #     SubnetId: !Ref PDCPublicSubnet # NAT must be in public subnet

  # Route private subnet traffic to NAT Gateway (for ECR pulls, CloudWatch logs)
  # PDCPrivateRoute:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref PDCPrivateRouteTable
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref PDCNATGateway #forward all private subnet traffic to NAT for internet access

  PVCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for VPC Interface Endpoints
      VpcId: !Ref PDCVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref PDCFargateSecurityGroup # Allows Fargate to "talk in"

  PDCFargateSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Fargate containers
      VpcId: !Ref PDCVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          SourceSecurityGroupId: !Ref PDCNLBSecurityGroup
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0 # Allows the task to reach the Endpoints

  # --- Interface Endpoint for (ECS Task -> ECR) --- #
  # AWS handles the routing of requests from the private subnet to the ECR service through this endpoint
  ECREndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true # allows us to use the normal ECR endpoint URLs and have them resolve to the VPC endpoint rather than going out to the public internet
      VpcEndpointType: Interface # (Interface / Gateway) defaults to Gateway, both interface and gateway use AWS::EC2::VPCEndpoint
      VpcId: !Ref PDCVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ecr.api" # ECR API endpoint for this region
      SubnetIds:
        - !Ref PDCPrivateSubnet # only tasks in private subnet need this endpoint
      SecurityGroupIds:
        - !Ref PVCEndpointSecurityGroup # allow ECS tasks to talk to this endpoint

  ECRDockerEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true # allows us to use the normal ECR endpoint URLs and have them resolve to the VPC endpoint rather than going out to the public internet
      VpcEndpointType: Interface
      VpcId: !Ref PDCVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ecr.dkr" # allows docker commands
      SubnetIds:
        - !Ref PDCPrivateSubnet
      SecurityGroupIds:
        - !Ref PVCEndpointSecurityGroup

  # --- S3 Gateway Endpoint --- # for getting ECR images
  S3Endpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref PDCVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.s3" # ecr images stored on S3
      VpcEndpointType: Gateway
      RouteTableIds:
        - !Ref PDCPrivateRouteTable

  # --- Interface Endpoint for CloudWatch Logs (ECS Task -> CloudWatch) --- #
  LogsEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      VpcEndpointType: Interface
      VpcId: !Ref PDCVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.logs"
      SubnetIds:
        - !Ref PDCPrivateSubnet
      SecurityGroupIds:
        - !Ref PVCEndpointSecurityGroup

  # --- Route Table for Private Subnet ---
  PDCPrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref PDCVPC

  PDCPrivateSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PDCPrivateSubnet
      RouteTableId: !Ref PDCPrivateRouteTable

  # --- DynamoDB Gateway Endpoint (private containers can access DynamoDB without NAT) ---
  PDCDynamoDBEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      # VpcEndpointType: Gateway #  (Interface / Gateway) defaults to Gateway, both interface and gateway use AWS::EC2::VPCEndpoint
      VpcId: !Ref PDCVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.dynamodb" # DynamoDB endpoint for this region
      RouteTableIds:
        - !Ref PDCPrivateRouteTable # Only private subnet needs this route
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: "*"
            Action:
              - dynamodb:GetItem
              - dynamodb:Query
              - dynamodb:Scan
              - dynamodb:BatchGetItem
            Resource: !GetAtt PDCDonutTable.Arn

  # --- Database: DynamoDB (On-Demand Pricing) ---
  PDCDonutTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: PDC-Inventory
      AttributeDefinitions:
        - AttributeName: ItemID
          AttributeType: S
      KeySchema:
        - AttributeName: ItemID # Partition Key
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST # Best for minimal/fluctuating traffic

  # --- IAM Role for Fargate to Access DynamoDB ---
  FargateTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: DynamoDBReadAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: !GetAtt PDCDonutTable.Arn

  # --- IAM Role for CodeBuild ---
  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryPowerUser
      Policies:
        - PolicyName: CodeBuildLogs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - s3:GetObject
                  - s3:PutObject
                Resource: "*"

  # --- ECR Repository ---
  PDCAppRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: pdc-app
      ImageScanningConfiguration:
        ScanOnPush: false # scans images for basic vulns (AWS Inspector is an add-on that does more advanced scanning)

  # --- CodeBuild Project ---
  PDCBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: pdc-app-build
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:5.0
        Type: LINUX_CONTAINER
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: ECR_REPO_NAME
            Value: pdc-app
          - Name: IMAGE_TAG
            Value: latest
      Source:
        Type: CODEPIPELINE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo Logging in to Amazon ECR...
                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
            build:
              commands:
                - IMAGE_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO_NAME:$IMAGE_TAG
                - echo Build started on `date`
                - echo Building the Docker image...
                - docker build -t $IMAGE_URI .
            post_build:
              commands:
                - echo Build completed on `date`
                - echo Pushing the Docker image...
                - docker push $IMAGE_URI
                - echo Writing image definitions file...
                - printf '[{"name":"pdc-app","imageUri":"%s"}]' $IMAGE_URI > imagedefinitions.json
          artifacts:
            files: imagedefinitions.json
          cache:
            paths:
              - '/go/pkg/**/*'

  # --- IAM Role for CodePipeline ---
  CodePipelineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codepipeline.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryFullAccess
        - arn:aws:iam::aws:policy/AmazonECS_FullAccess
      Policies:
        - PolicyName: CodePipelinePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:*
                  - ecs:*
                  - codecommit:*
                  - s3:*
                Resource: "*"

  # --- Artifact Store (S3 Bucket) for CodePipeline ---
  PipelineArtifactsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "pdc-pipeline-artifacts-${AWS::AccountId}"
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true # blocks new public ACLs and ignores any existing public ACLs on the bucket
        BlockPublicPolicy: true # blocks new and existing public policies on the bucket
        IgnorePublicAcls: true # ignores any public ACLs on the bucket and objects
        RestrictPublicBuckets: true # restricts access to the bucket to only AWS services and authed users
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LoggingConfiguration:
        DestinationBucketName: !Ref ArtifactsLogBucket
        LogFilePrefix: pipeline-logs/
      LifecycleConfiguration:
        Rules:
          - Id: ExpireArtifacts
            Status: Enabled
            ExpirationInDays: 3

  ArtifactsLogBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "pdc-pipeline-logs-${AWS::AccountId}"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
          - Id: ExpireArtifacts
            Status: Enabled
            ExpirationInDays: 3

  # --- CodePipeline ---
  PDCPipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      Name: pdc-app-pipeline
      RoleArn: !GetAtt CodePipelineRole.Arn
      ArtifactStore:
        Type: S3
        Location: !Ref PipelineArtifactsBucket
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: ThirdParty
                Provider: GitHub
                Version: "1"
              Configuration:
                Owner: benhagg
                Repo: IS590R-ch11
                Branch: master
                OAuthToken: !Ref GitHubOAuthToken
              OutputArtifacts:
                - Name: SourceOutput

        - Name: Build
          Actions:
            - Name: BuildAction
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: "1"
              Configuration:
                ProjectName: !Ref PDCBuildProject
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildOutput

        - Name: DeployApp
          Actions:
            - Name: DeployAction
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: "1"
              # ECS deploy reads imagedefinitions.json (container name -> image URI),
              # creates a new task definition revision, and updates the service to it
              Configuration:
                ClusterName: !Ref FargateCluster
                ServiceName: !GetAtt PDCService.Name
                FileName: imagedefinitions.json
              InputArtifacts:
                - Name: BuildOutput

        - Name: DeployStaticSite
          Actions:
            - Name: S3DeployStaticSite
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: S3
                Version: "1"
              Configuration:
                BucketName: !Ref WebsiteS3
                Extract: true
              InputArtifacts:
                - Name: SourceOutput

  # --- IAM Role for ECS Task Execution ---
  FargateTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
      Policies:
        - PolicyName: ECRAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource: "*"

  # --- Network Load Balancer (in private subnet, only reachable via VPC Link) ---
  PDCNetworkLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: pdc-app-nlb
      Type: network
      Scheme: internal
      Subnets:
        - !Ref PDCPrivateSubnet
      SecurityGroups:
        - !Ref PDCNLBSecurityGroup

  PDCTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: pdc-app-targets
      Port: 8080
      Protocol: TCP
      VpcId: !Ref PDCVPC
      TargetType: ip
      HealthCheckEnabled: true
      HealthCheckProtocol: TCP
      HealthCheckPort: "8080"
      HealthCheckIntervalSeconds: 30
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: proxy_protocol_v2.enabled
          Value: "false"
        - Key: preserve_client_ip.enabled
          Value: "false"

  PDCNLBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref PDCNetworkLoadBalancer
      Port: 8080
      Protocol: TCP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref PDCTargetGroup

  # --- HTTP API Gateway with VPC Link ---
  # creates an ENI in the PRIVATE subnet and routes API Gateway traffic to the NLB through it
  PDCVPCLink:
    Type: AWS::ApiGatewayV2::VpcLink
    Properties:
      Name: pdc-vpc-link
      SubnetIds:
        - !Ref PDCPrivateSubnet # VPC Link ENI goes in private subnet
      SecurityGroupIds:
        - !Ref PDCVPCLinkSecurityGroup

  # --- Security Groups ---
  # PDCNLBSecurityGroup:
  #   Type: AWS::EC2::SecurityGroup
  #   Properties:
  #     GroupDescription: Security group for Network Load Balancer
  #     VpcId: !Ref PDCVPC
  #     SecurityGroupIngress:
  #       - IpProtocol: tcp
  #         FromPort: 8080
  #         ToPort: 8080
  #         SourceSecurityGroupId: !Ref PDCVPCLinkSecurityGroup
  #     SecurityGroupEgress:
  #       - IpProtocol: "-1" # all protocols
  #         CidrIp: 0.0.0.0/0

  # PDCVPCLinkSecurityGroup:
  #   Type: AWS::EC2::SecurityGroup
  #   Properties:
  #     GroupDescription: Security group for the VPC Link ENI (allows API Gateway to talk to NLB)
  #     VpcId: !Ref PDCVPC
  #     SecurityGroupIngress:
  #       - IpProtocol: tcp
  #         FromPort: 8080
  #         ToPort: 8080
  #         CidrIp: 0.0.0.0/0 # API Gateway traffic enters here
  #     SecurityGroupEgress: # this is required to talk to the NLB
  #       - IpProtocol: tcp
  #         FromPort: 8080
  #         ToPort: 8080
  #         DestinationSecurityGroupId: !Ref PDCNLBSecurityGroup

  PDCNLBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Network Load Balancer
      VpcId: !Ref PDCVPC
      # ONLY keep rules that don't point to the VPC Link Group here
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0

  PDCVPCLinkSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for the VPC Link ENI
      VpcId: !Ref PDCVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          CidrIp: 0.0.0.0/0

  # This allows the VPC Link to talk TO the NLB
  VPCLinkToNLBEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref PDCVPCLinkSecurityGroup
      IpProtocol: tcp
      FromPort: 8080
      ToPort: 8080
      DestinationSecurityGroupId: !Ref PDCNLBSecurityGroup

  # This allows the NLB to accept traffic FROM the VPC Link
  NLBFromVPCLinkIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref PDCNLBSecurityGroup
      IpProtocol: tcp
      FromPort: 8080
      ToPort: 8080
      SourceSecurityGroupId: !Ref PDCVPCLinkSecurityGroup

  PDCApiGateway:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: pdc-app-api
      ProtocolType: HTTP
      Description: API Gateway for PDC App

  PDCApiIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PDCApiGateway
      IntegrationType: HTTP_PROXY # takes the incoming request and passes it exactly as-is to NLB other options: AWS (direct to dynamo or S3), AWS_PROXY (lambda)
      IntegrationUri: !Ref PDCNLBListener # hits the VPC dns server at 169.254.169.253 or .2 to get the private ip of the NLB
      IntegrationMethod: ANY # which HTTP methods the API Gateway endpoint accepts.
      PayloadFormatVersion: "1.0" # 2.0 for modern HTTP APIs (lambda only).
      ConnectionType: VPC_LINK # used VPC Link and AWS private network to connect. Alternative is INTERNET which would require the NLB to be internet-facing and API Gateway would connect over the public internet
      ConnectionId: !Ref PDCVPCLink
      RequestParameters:
        "overwrite:path": "$request.path" # passes the full path through but removes the stage name (/prod)

  PDCApiRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PDCApiGateway
      RouteKey: "ANY /{proxy+}" # any means it handles any HTTP method, {proxy+} means it matches any path
      Target: !Sub "integrations/${PDCApiIntegration}" # links to integration id above -> NLB -> Fargate containers

  PDCApiDefaultRoute: # default route for root path ("/") since {proxy+} doesn't match it
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PDCApiGateway
      RouteKey: "$default"
      Target: !Sub "integrations/${PDCApiIntegration}"

  PDCApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref PDCApiGateway
      StageName: prod
      AutoDeploy: true

  # --- Fargate Infrastructure ---
  FargateCluster: # defines what infastructure (compute) can hold the containers. In EC2 or External mode they are attached here
    Type: AWS::ECS::Cluster

  # below 2 resources are used if the launch type is EC2 (not needed for fargate)

  # # --- 2. EC2 Launch Template (The Attachment) ---
  # PDCLaunchTemplate:
  #   Type: AWS::EC2::LaunchTemplate
  #   Properties:
  #     LaunchTemplateData:
  #       ImageId: ami-0c55b159cbfafe1f0 # Update to your region's ECS-Optimized AMI
  #       InstanceType: t3.micro
  #       IamInstanceProfile:
  #         Name: !Ref PDCInstanceProfile
  #       # THIS ATTACHES THE EC2 TO THE CLUSTER
  #       UserData:
  #         Fn::Base64: !Sub |
  #           #!/bin/bash
  #           echo ECS_CLUSTER=${PDCCluster} >> /etc/ecs/ecs.config

  # # --- 3. Auto Scaling Group ---
  # PDCASG:
  #   Type: AWS::AutoScaling::AutoScalingGroup
  #   Properties:
  #     VPCZoneIdentifier: [!Ref PublicSubnetID]
  #     LaunchTemplate:
  #       LaunchTemplateId: !Ref PDCLaunchTemplate
  #       Version: !GetAtt PDCLaunchTemplate.LatestVersionNumber
  #     MinSize: '1'
  #     MaxSize: '2'
  #     DesiredCapacity: '1'

  PDCAppTask: # recipe with which to create containers
    Type: AWS::ECS::TaskDefinition
    Properties:
      RequiresCompatibilities:
        - FARGATE
      NetworkMode: awsvpc
      Cpu: "256"
      Memory: "512"
      TaskRoleArn: !Ref FargateTaskRole #used by application code (DynamoDB access)
      ExecutionRoleArn: !GetAtt FargateTaskExecutionRole.Arn # used by ECS to pull image and send logs to CloudWatch
      ContainerDefinitions:
        - Name: pdc-app
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/pdc-app:latest"
          Environment:
            - Name: TABLE_NAME
              Value: !Ref PDCDonutTable
            - Name: AWS_REGION
              Value: !Ref "AWS::Region"
          PortMappings:
            - ContainerPort: 8080
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref PDCLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: pdc-app
          # HealthCheck:
          #   Command: ["CMD-SHELL", "curl -f http://localhost/health || exit 1"]
          #   Interval: 30
          #   Timeout: 5
          #   Retries: 3
          #   StartPeriod: 60
          # - HostPort : 80 # for EC2 launch type. only allows one container per instance
          # - HostPort : 0 # for EC2 launch type. uses dynamic port mapping to allow many containers per instance

  PDCService: # manages tasks (containers), is the control node
    Type: AWS::ECS::Service
    DependsOn: PDCNLBListener
    Properties:
      Cluster: !Ref FargateCluster
      TaskDefinition: !Ref PDCAppTask
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED # Private subnet - no public IPs needed
          Subnets:
            - !Ref PDCPrivateSubnet # Run in private subnet
          SecurityGroups:
            - !Ref PDCFargateSecurityGroup
      LoadBalancers:
        - ContainerName: pdc-app
          ContainerPort: 8080
          TargetGroupArn: !Ref PDCTargetGroup

  # --- CloudWatch Log Group ---
  PDCLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /ecs/pdc-app
      RetentionInDays: 1

  WebsiteS3:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "pdc-website-assets-${AWS::AccountId}"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true # blocks new public ACLs and ignores any existing public ACLs on the bucket
        BlockPublicPolicy: true # blocks new and existing public policies on the bucket
        IgnorePublicAcls: true # ignores any public ACLs on the bucket and objects
        RestrictPublicBuckets: true # restricts access to the bucket to only AWS services (CloudFront) and authed users

  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Description: "OAC for S3 Website"
        Name: pdc-donuts-OAC
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  S3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebsiteS3
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub "${WebsiteS3.Arn}/*"
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${WebCloudFront}"

  WebCloudFront:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt WebsiteS3.RegionalDomainName
            OriginAccessControlId: !Ref CloudFrontOAC # limits access to the S3 bucket to the cloudfront distribution authorized by the OAC
            S3OriginConfig:
              OriginAccessIdentity: "" # Required by CloudFormation, empty string when using OAC
        Enabled: true
        DefaultRootObject: index.html # serve index.html file when hitting the S3 bucket URL
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
          CachedMethods:
            - GET
            - HEAD
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6 # Managed-CachingOptimized policy

Outputs:
  ECRRepositoryURL:
    Description: ECR Repository URL for Docker images
    Value: !GetAtt PDCAppRepository.RepositoryUri
    Export:
      Name: PDCECRRepositoryURI

  CodePipelineURL:
    Description: CodePipeline console URL
    Value: !Sub "https://console.aws.amazon.com/codepipeline/home?region=${AWS::Region}#/view/${PDCPipeline}"

  DynamoDBTableName:
    Description: DynamoDB table name
    Value: !Ref PDCDonutTable

  ECSClusterName:
    Description: ECS Cluster name
    Value: !Ref FargateCluster

  ECSServiceName:
    Description: ECS Service name
    Value: !GetAtt PDCService.Name

  CloudFrontURL:
    Description: CloudFront distribution URL for website
    Value: !GetAtt WebCloudFront.DomainName

  APIGatewayEndpoint:
    Description: HTTP API Gateway endpoint URL
    Value: !Sub "https://${PDCApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod"

  NetworkLoadBalancerDNS:
    Description: Network Load Balancer DNS name
    Value: !GetAtt PDCNetworkLoadBalancer.DNSName
